#中文乱码详解

##字的最终存储格式
首先需要明白的一个事情就是`字`是怎么存储在电脑里的：二进制。

##ASCII表
最开始学编程的人应该会接触到一个编码，也就是`ASCII`。这个编码表表示了一系列二进制数据对应的字符是什么。

例如字母`A`在这个表里面对应的数据是`65`，那么`65`就是电脑存储`A`所用的数据，换算成二进制是`1000001`。这里需要注意的是讨论的是用`ASCII`进行编码转换，如果不进行转换，`1000001`就是`1000001`，它不代表`A`，它有可能是其他数据也有可能是更长数据的一部分。

总结一下:`ASCII`编码下，二进制数据可以被对应映射为字符。

##unicode
一开始计算机和代码仅仅是极少一部分人能使用的，随着计算机的发展，越来越多的人用上了电脑，这个时候就发现，如果要显示汉字怎么办，上面提到的`ASCII`总共才1个字节，最多255种（全0的情况排外）组合，但是不仅是汉字，包括各国语言的文字完全不够存进去呀。这个时候出现了很多不同的类似`ASCII`的表，例如`ISO 8859-1`，这些表更大，可以表示的字的数量也就越多。但是用着用着大家就发现，这些编码表有一些问题（与本文无关不深入），于是`unicode`这种统一编码表发明了。

在最开始的`unicode`也一样可以看做是大点的`ASCII`表，它每个字在最开始的时候设定是的2个字节（现在最新的标准已经扩充到4个字节了），也就说可以表示65535种字（最新的可以表示2147483648个字）

##UTF8
上文有说过unicode编码表用一一映射的关系表示了二进制数据对应的汉字关系，但是人们在使用的过程中发现，即使一个字母能用一个字节表示的，也仍然是固定用两个字节表示。这在于传输的过程中，无疑是一种巨大的浪费。那么`UTF-8`编码就诞生了。它是一种变长的编码，也就是说，一个字母是1一个字节表示，但是一个汉字可能是两个字节或者三个字节等。

##文字数据的传输流程
文字数据无非就是三种个主要流程

输入->程序->输出

* 输入，一般就是你的字符串到你的代码内存中的入口。例如你写数据库操作从数据库取数据存到你的变量中，这就是从数据库输入。你写代码里面直接赋值一个字符串给变量，这也是输入。
* 程序，程序内部存储变量是在内存中，以二进制存储，除非到了输出或者进行字符编码等操作，是不会理会里面到底存的是什么的。
* 输出，就是你要显示文字的地方或者传输文字数据给别人。例如你打印出来算输出，把二进制传输给别人也算输出。

首先整个流程上，明确一个观点，只要我们的二进制数据保持正确，那么文字就可以被正确的显示出来，现在从上面三个流程上我们来把关。

###输入
* 如果是从外界直接传输数据过来，那么得查看外界输入的是什么编码形式的数据。例如数据库的话那么就得看数据库的存储编码，这个一般在建表的时候选择的。
* 如果是代码里面的字符串常量，取决于当前代码文件的编码。因为代码是被编译器解析的，编译器需要读取你的代码文件，那么代码文件里面写的文字编码就取决于文件的编码了。用notepad++等工具可以看到文本编码。

###程序
不同的框架用的接受外部输入的方法不同，得查阅相关文档。但是内部存储格式我们并不关心，这里相当于又是一个输入输出的关系。

变量接受外部的数据 -> 变量内部存储（我们不关心）-> 变量输出文字

* 变量接受外部数据要取决于代码的编写方法例如：

    QString str;
    str = "这是文字";

  这串代码表示在QString对象里面存储一串文字，那么存储过程如何呢？

  1.首先str被实例化，此时内容为空
  2.str被赋值`"这是文字"`，按照C++的语法调用的是等号重载，那么在[QString的文档里面](http://doc.qt.io/qt-5/qstring.html#operator-eq-4)是这样说的
  > Assigns str to this string. The const char pointer is converted to Unicode using the fromUtf8() function.

  也就是说这个这串char指针(也就是`"这是文字"`)是被`fromUtf8()`函数作为参数存入QString中的。那现在还有一个点就是`"这是文字"`到底是什么编码呢？这取决于这串文字在的文件本身的文件编码。也就是说，现在你看到的这个文件编码是UTF-8，那么这里这个`"这是文字"`就是UTF-8编码。那么被`fromUtf8()`作为参数存入QString就可以正确的解析出它自己统一的格式。为什么会需要再解码一次呢？因为`QString`采用一种编码方法就需要兼容其他的方法，必然需要解码其他格式的数据为自己的编码格式。

  打个比方，`"字"`的unicode编码二进制是`1111 1111 1111 1111`(假设，实际值不是这样)，写在UTF-8编码的文件上，它的二进制
  可能是`1010 1010 1010`(假设)，那么`fromUtf8()`收到的是后者。假设QString内部用的是unicode编码，那么它实际上是把收到的`1010 1010 1010`转换成了`1111 1111 1111 1111`。

  所以这里就是乱码最容易出现的地方，通常我们用的windows系统默认编码是GBK，那么用记事本新建的文件，或者编辑工具使用系统默认编码，都会使用GBK。GBK是不同于UTF-8的编码方式，所以如果你的文件用的GBK，而又直接用等号赋值给了`QString`，那么`QString`就会按照UTF-8的格式去解码，结果当然是解错了，存在`QString`内部的二进制数据也将是错的。这样输出的代码即使再正确也还是错误的输出。

* 另外一种情况是数据本身是从外部输入，并不是常量写在代码里面。那么得取决于传输方的数据格式和传输方式了。

  举个例子。如果你是用`MySQL`获取数据，那么在建表的时候是用编码可以选择的，这个时候选择的编码决定了你的数据存放时的编码方式。

  假设你外部数据（不仅仅是MySQL）使用的UTF-8，那么你也还需要在传输的过程中约定好收发双方的编码方式，你传输的是UTF-8的二进制，那么在接受的时候也需要使用UTF-8的方式解码接受的数据。具体的来说就是收到的bytes需要`fromUtf8()`来存入QString。如果是其他编码方式，接收方也需要用对应的解码方式。

###输出
当你成功的将文本正确存入`QString`，但是又发现没法正确的显示中文，这一般就是涉及到输出的部分了。

前面有说到，`QString`内部用自己的方式存储了你的文本正确的二进制数据，它自己能够对应到正确的字上面去，但是其他的程序可不知道有`QString`这个玩意。它们也只知道有一些通用的编码规则例如`UTF-8`，`GBK`等。那么这个时候，你需要做的是把你存在`QString`里的二进制转换成输出接受的一方认同的编码格式。

例如有一个程序仅支持`UTF-8`的编码，那么你用`QString::toLatin1()`肯定是转换成了别的编码，这个时候输出的接收方自己用`UTF-8`解析，结果就乱码了。

##local8bit
`QString`有一个`QString::toLocal8Bit`和`QString::fromLocal8Bit`一对方法。这两个方法用的是`QTextCodec::codecForLocale()`决定的转换方法。文档说明如下:
> Returns a pointer to the codec most suitable for this locale.
>  
On Windows, the codec will be based on a system locale. On Unix systems, the codec will might fall back to using the iconv library if no builtin codec for the locale can be found.
>
Note that in these cases the codec's name will be "System".

大体的意思就是说会返回本地最适合的编码方法。例如在大家用的windows机器上，一般是`GBK`编码（可以自己改系统设置）。

那么就会出现一种现象，很多时候乱码使用`QString::fromLocal8Bit`或`QString::toLocal8Bit`就能解决。究其原因就是使用`QString::fromLocal8Bit`实际上你把你在GBK格式文件上写的字符常量或者GBK格式的数据来源转换成了正确的二进制存储在`QString`上，而`QString::toLocal8Bit`则是把正确的二进制以`GBK`的编码格式传输给了展示文字的接收方，而接收方恰好需要的就是`GBK`编码的文字。

##总结和建议
总结就是把关好输入和输出，搞清楚你塞给`QString`的是什么编码格式的字符串，用的什么解码接口传入的。搞清楚你用`QString`的什么编码方式传出的字符串，展现字符串的接收方需要的什么编码格式。

建议就是，将你的文件格式强制转为`UTF-8`，编码/解码过程全程使用`UTF-8`(win32系列api用unicode，即`wchar_t`)。

此指南理念不仅仅局限于特别的框架或者编程语言。